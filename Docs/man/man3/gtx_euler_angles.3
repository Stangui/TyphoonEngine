.TH "gtx_euler_angles" 3 "Sat Jul 20 2019" "Version 0.1" "Typhoon Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
gtx_euler_angles
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleX\fP (T const &angleX)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleY\fP (T const &angleY)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleZ\fP (T const &angleZ)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::derivedEulerAngleX\fP (T const &angleX, T const &angularVelocityX)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::derivedEulerAngleY\fP (T const &angleY, T const &angularVelocityY)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::derivedEulerAngleZ\fP (T const &angleZ, T const &angularVelocityZ)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleXY\fP (T const &angleX, T const &angleY)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleYX\fP (T const &angleY, T const &angleX)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleXZ\fP (T const &angleX, T const &angleZ)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleZX\fP (T const &\fBangle\fP, T const &angleX)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleYZ\fP (T const &angleY, T const &angleZ)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleZY\fP (T const &angleZ, T const &angleY)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleXYZ\fP (T const &t1, T const &t2, T const &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleYXZ\fP (T const &\fByaw\fP, T const &\fBpitch\fP, T const &\fBroll\fP)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleXZX\fP (T const &t1, T const &t2, T const &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleXYX\fP (T const &t1, T const &t2, T const &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleYXY\fP (T const &t1, T const &t2, T const &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleYZY\fP (T const &t1, T const &t2, T const &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleZYZ\fP (T const &t1, T const &t2, T const &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleZXZ\fP (T const &t1, T const &t2, T const &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleXZY\fP (T const &t1, T const &t2, T const &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleYZX\fP (T const &t1, T const &t2, T const &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleZYX\fP (T const &t1, T const &t2, T const &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::eulerAngleZXY\fP (T const &t1, T const &t2, T const &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 4, 4, T, defaultp > \fBglm::yawPitchRoll\fP (T const &\fByaw\fP, T const &\fBpitch\fP, T const &\fBroll\fP)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 2, 2, T, defaultp > \fBglm::orientate2\fP (T const &\fBangle\fP)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL \fBmat\fP< 3, 3, T, defaultp > \fBglm::orientate3\fP (T const &\fBangle\fP)"
.br
.ti -1c
.RI "template<typename T , qualifier Q> GLM_FUNC_DECL \fBmat\fP< 3, 3, T, Q > \fBglm::orientate3\fP (\fBvec\fP< 3, T, Q > const &angles)"
.br
.ti -1c
.RI "template<typename T , qualifier Q> GLM_FUNC_DECL \fBmat\fP< 4, 4, T, Q > \fBglm::orientate4\fP (\fBvec\fP< 3, T, Q > const &angles)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleXYZ\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleYXZ\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleXZX\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleXYX\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleYXY\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleYZY\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleZYZ\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleZXZ\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleXZY\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleYZX\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleZYX\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_DECL void \fBglm::extractEulerAngleZXY\fP (\fBmat\fP< 4, 4, T, defaultp > const &M, T &t1, T &t2, T &t3)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Include <\fBglm/gtx/euler_angles\&.hpp\fP> to use the features of this extension\&.
.PP
Build matrices from Euler angles\&.
.PP
Extraction of Euler angles from rotation matrix\&. Based on the original paper 2014 Mike Day - Extracting Euler Angles from a Rotation Matrix\&. 
.SH "Function Documentation"
.PP 
.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::derivedEulerAngleX (T const & angleX, T const & angularVelocityX)"
Creates a 3D 4 * 4 homogeneous derived matrix from the rotation matrix about X-axis\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::derivedEulerAngleY (T const & angleY, T const & angularVelocityY)"
Creates a 3D 4 * 4 homogeneous derived matrix from the rotation matrix about Y-axis\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::derivedEulerAngleZ (T const & angleZ, T const & angularVelocityZ)"
Creates a 3D 4 * 4 homogeneous derived matrix from the rotation matrix about Z-axis\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleX (T const & angleX)"
Creates a 3D 4 * 4 homogeneous rotation matrix from an euler angle X\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleXY (T const & angleX, T const & angleY)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (X * Y)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleXYX (T const & t1, T const & t2, T const & t3)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (X * Y * X)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleXYZ (T const & t1, T const & t2, T const & t3)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (X * Y * Z)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleXZ (T const & angleX, T const & angleZ)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (X * Z)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleXZX (T const & t1, T const & t2, T const & t3)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (X * Z * X)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleXZY (T const & t1, T const & t2, T const & t3)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (X * Z * Y)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleY (T const & angleY)"
Creates a 3D 4 * 4 homogeneous rotation matrix from an euler angle Y\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleYX (T const & angleY, T const & angleX)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * X)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleYXY (T const & t1, T const & t2, T const & t3)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * X * Y)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleYXZ (T const & yaw, T const & pitch, T const & roll)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * X * Z)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleYZ (T const & angleY, T const & angleZ)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * Z)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleYZX (T const & t1, T const & t2, T const & t3)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * Z * X)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleYZY (T const & t1, T const & t2, T const & t3)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * Z * Y)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleZ (T const & angleZ)"
Creates a 3D 4 * 4 homogeneous rotation matrix from an euler angle Z\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleZX (T const & angle, T const & angleX)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Z * X)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleZXY (T const & t1, T const & t2, T const & t3)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Z * X * Y)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleZXZ (T const & t1, T const & t2, T const & t3)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Z * X * Z)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleZY (T const & angleZ, T const & angleY)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Z * Y)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleZYX (T const & t1, T const & t2, T const & t3)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Z * Y * X)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::eulerAngleZYZ (T const & t1, T const & t2, T const & t3)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Z * Y * Z)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleXYX (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (X * Y * X) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleXYZ (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (X * Y * Z) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleXZX (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (X * Z * X) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleXZY (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (X * Z * Y) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleYXY (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (Y * X * Y) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleYXZ (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (Y * X * Z) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleYZX (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (Y * Z * X) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleYZY (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (Y * Z * Y) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleZXY (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (Z * X * Y) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleZXZ (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (Z * X * Z) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleZYX (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (Z * Y * X) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL void glm::extractEulerAngleZYZ (\fBmat\fP< 4, 4, T, defaultp > const & M, T & t1, T & t2, T & t3)"
Extracts the (Z * Y * Z) Euler angles from the rotation matrix M 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<2, 2, T, defaultp> glm::orientate2 (T const & angle)"
Creates a 2D 2 * 2 rotation matrix from an euler angle\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<3, 3, T, defaultp> glm::orientate3 (T const & angle)"
Creates a 2D 4 * 4 homogeneous rotation matrix from an euler angle\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T , qualifier Q> GLM_FUNC_DECL \fBmat\fP<3, 3, T, Q> glm::orientate3 (\fBvec\fP< 3, T, Q > const & angles)"
Creates a 3D 3 * 3 rotation matrix from euler angles (Y * X * Z)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T , qualifier Q> GLM_FUNC_DECL \fBmat\fP<4, 4, T, Q> glm::orientate4 (\fBvec\fP< 3, T, Q > const & angles)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * X * Z)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SS "template<typename T > GLM_FUNC_DECL \fBmat\fP<4, 4, T, defaultp> glm::yawPitchRoll (T const & yaw, T const & pitch, T const & roll)"
Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * X * Z)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTX_euler_angles\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Typhoon Engine from the source code\&.
