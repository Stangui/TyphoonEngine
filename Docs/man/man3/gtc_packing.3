.TH "gtc_packing" 3 "Sat Jul 20 2019" "Version 0.1" "Typhoon Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
gtc_packing
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "GLM_FUNC_DECL \fBuint8\fP \fBglm::packUnorm1x8\fP (float v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL float \fBglm::unpackUnorm1x8\fP (\fBuint8\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packUnorm2x8\fP (\fBvec2\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec2\fP \fBglm::unpackUnorm2x8\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint8\fP \fBglm::packSnorm1x8\fP (float s)"
.br
.ti -1c
.RI "GLM_FUNC_DECL float \fBglm::unpackSnorm1x8\fP (\fBuint8\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packSnorm2x8\fP (\fBvec2\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec2\fP \fBglm::unpackSnorm2x8\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packUnorm1x16\fP (float v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL float \fBglm::unpackUnorm1x16\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint64\fP \fBglm::packUnorm4x16\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackUnorm4x16\fP (\fBuint64\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packSnorm1x16\fP (float v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL float \fBglm::unpackSnorm1x16\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint64\fP \fBglm::packSnorm4x16\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackSnorm4x16\fP (\fBuint64\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packHalf1x16\fP (float v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL float \fBglm::unpackHalf1x16\fP (\fBuint16\fP v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint64\fP \fBglm::packHalf4x16\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackHalf4x16\fP (\fBuint64\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packI3x10_1x2\fP (\fBivec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBivec4\fP \fBglm::unpackI3x10_1x2\fP (\fBuint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packU3x10_1x2\fP (\fBuvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuvec4\fP \fBglm::unpackU3x10_1x2\fP (\fBuint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packSnorm3x10_1x2\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackSnorm3x10_1x2\fP (\fBuint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packUnorm3x10_1x2\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackUnorm3x10_1x2\fP (\fBuint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packF2x11_1x10\fP (\fBvec3\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec3\fP \fBglm::unpackF2x11_1x10\fP (\fBuint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packF3x9_E1x5\fP (\fBvec3\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec3\fP \fBglm::unpackF3x9_E1x5\fP (\fBuint32\fP p)"
.br
.ti -1c
.RI "template<length_t L, typename T , qualifier Q> GLM_FUNC_DECL \fBvec\fP< 4, T, Q > \fBglm::packRGBM\fP (\fBvec\fP< 3, T, Q > const &\fBrgb\fP)"
.br
.ti -1c
.RI "template<length_t L, typename T , qualifier Q> GLM_FUNC_DECL \fBvec\fP< 3, T, Q > \fBglm::unpackRGBM\fP (\fBvec\fP< 4, T, Q > const &rgbm)"
.br
.ti -1c
.RI "template<length_t L, qualifier Q> GLM_FUNC_DECL \fBvec\fP< L, \fBuint16\fP, Q > \fBglm::packHalf\fP (\fBvec\fP< L, float, Q > const &v)"
.br
.ti -1c
.RI "template<length_t L, qualifier Q> GLM_FUNC_DECL \fBvec\fP< L, float, Q > \fBglm::unpackHalf\fP (\fBvec\fP< L, \fBuint16\fP, Q > const &p)"
.br
.ti -1c
.RI "template<typename uintType , length_t L, typename floatType , qualifier Q> GLM_FUNC_DECL \fBvec\fP< L, uintType, Q > \fBglm::packUnorm\fP (\fBvec\fP< L, floatType, Q > const &v)"
.br
.ti -1c
.RI "template<typename floatType , length_t L, typename uintType , qualifier Q> GLM_FUNC_DECL \fBvec\fP< L, floatType, Q > \fBglm::unpackUnorm\fP (\fBvec\fP< L, uintType, Q > const &v)"
.br
.ti -1c
.RI "template<typename intType , length_t L, typename floatType , qualifier Q> GLM_FUNC_DECL \fBvec\fP< L, intType, Q > \fBglm::packSnorm\fP (\fBvec\fP< L, floatType, Q > const &v)"
.br
.ti -1c
.RI "template<typename floatType , length_t L, typename intType , qualifier Q> GLM_FUNC_DECL \fBvec\fP< L, floatType, Q > \fBglm::unpackSnorm\fP (\fBvec\fP< L, intType, Q > const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint8\fP \fBglm::packUnorm2x4\fP (\fBvec2\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec2\fP \fBglm::unpackUnorm2x4\fP (\fBuint8\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packUnorm4x4\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackUnorm4x4\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packUnorm1x5_1x6_1x5\fP (\fBvec3\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec3\fP \fBglm::unpackUnorm1x5_1x6_1x5\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packUnorm3x5_1x1\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackUnorm3x5_1x1\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint8\fP \fBglm::packUnorm2x3_1x2\fP (\fBvec3\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec3\fP \fBglm::unpackUnorm2x3_1x2\fP (\fBuint8\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBint16\fP \fBglm::packInt2x8\fP (\fBi8vec2\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBi8vec2\fP \fBglm::unpackInt2x8\fP (\fBint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packUint2x8\fP (\fBu8vec2\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBu8vec2\fP \fBglm::unpackUint2x8\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBint32\fP \fBglm::packInt4x8\fP (\fBi8vec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBi8vec4\fP \fBglm::unpackInt4x8\fP (\fBint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packUint4x8\fP (\fBu8vec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBu8vec4\fP \fBglm::unpackUint4x8\fP (\fBuint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL int \fBglm::packInt2x16\fP (\fBi16vec2\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBi16vec2\fP \fBglm::unpackInt2x16\fP (int p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBint64\fP \fBglm::packInt4x16\fP (\fBi16vec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBi16vec4\fP \fBglm::unpackInt4x16\fP (\fBint64\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL uint \fBglm::packUint2x16\fP (\fBu16vec2\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBu16vec2\fP \fBglm::unpackUint2x16\fP (uint p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint64\fP \fBglm::packUint4x16\fP (\fBu16vec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBu16vec4\fP \fBglm::unpackUint4x16\fP (\fBuint64\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBint64\fP \fBglm::packInt2x32\fP (\fBi32vec2\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBi32vec2\fP \fBglm::unpackInt2x32\fP (\fBint64\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint64\fP \fBglm::packUint2x32\fP (\fBu32vec2\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBu32vec2\fP \fBglm::unpackUint2x32\fP (\fBuint64\fP p)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Include <\fBglm/gtc/packing\&.hpp\fP> to use the features of this extension\&.
.PP
This extension provides a set of function to convert vertors to packed formats\&. 
.SH "Function Documentation"
.PP 
.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packF2x11_1x10 (\fBvec3\fP const & v)"
First, converts the first two components of the normalized floating-point value v into 11-bit signless floating-point values\&. Then, converts the third component of the normalized floating-point value v into a 10-bit signless floating-point value\&. Then, the results are packed into the returned 32-bit unsigned integer\&.
.PP
The first vector component specifies the 11 least-significant bits of the result; the last component specifies the 10 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec3\fP unpackF2x11_1x10(uint32 const& p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packF3x9_E1x5 (\fBvec3\fP const & v)"
First, converts the first two components of the normalized floating-point value v into 11-bit signless floating-point values\&. Then, converts the third component of the normalized floating-point value v into a 10-bit signless floating-point value\&. Then, the results are packed into the returned 32-bit unsigned integer\&.
.PP
The first vector component specifies the 11 least-significant bits of the result; the last component specifies the 10 most-significant bits\&.
.PP
packF3x9_E1x5 allows encoding into RGBE / RGB9E5 format
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec3\fP unpackF3x9_E1x5(uint32 const& p) 
.RE
.PP

.SS "template<length_t L, qualifier Q> GLM_FUNC_DECL \fBvec\fP<L, \fBuint16\fP, Q> glm::packHalf (\fBvec\fP< L, float, Q > const & v)"
Returns an unsigned integer vector obtained by converting the components of a floating-point vector to the 16-bit floating-point representation found in the OpenGL Specification\&. The first vector component specifies the 16 least-significant bits of the result; the forth component specifies the 16 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
vec<L, float, Q> \fBunpackHalf(vec<L, uint16, Q> const& p)\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packHalf1x16 (float v)"
Returns an unsigned integer obtained by converting the components of a floating-point scalar to the 16-bit floating-point representation found in the OpenGL Specification, and then packing this 16-bit value into a 16-bit unsigned integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackHalf2x16(vec2 const& v)\fP 
.PP
\fBuint64\fP \fBpackHalf4x16(vec4 const& v)\fP 
.PP
\fCGLSL packHalf2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint64\fP glm::packHalf4x16 (\fBglm::vec4\fP const & v)"
Returns an unsigned integer obtained by converting the components of a four-component floating-point vector to the 16-bit floating-point representation found in the OpenGL Specification, and then packing these four 16-bit values into a 64-bit unsigned integer\&. The first vector component specifies the 16 least-significant bits of the result; the forth component specifies the 16 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP packHalf1x16(float const& v) 
.PP
\fBuint32\fP \fBpackHalf2x16(vec2 const& v)\fP 
.PP
\fCGLSL packHalf2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packI3x10_1x2 (\fBivec4\fP const & v)"
Returns an unsigned integer obtained by converting the components of a four-component signed integer vector to the 10-10-10-2-bit signed integer representation found in the OpenGL Specification, and then packing these four values into a 32-bit unsigned integer\&. The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP packI3x10_1x2(uvec4 const& v) 
.PP
\fBuint32\fP \fBpackSnorm3x10_1x2(vec4 const& v)\fP 
.PP
\fBuint32\fP \fBpackUnorm3x10_1x2(vec4 const& v)\fP 
.PP
\fBivec4\fP unpackI3x10_1x2(uint32 const& p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER int glm::packInt2x16 (\fBi16vec2\fP const & v)"
Convert each component from an integer vector into a packed integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBi16vec2\fP \fBunpackInt2x16(int p)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBint64\fP glm::packInt2x32 (\fBi32vec2\fP const & v)"
Convert each component from an integer vector into a packed integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBi32vec2\fP unpackInt2x32(int p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBint16\fP glm::packInt2x8 (\fBi8vec2\fP const & v)"
Convert each component from an integer vector into a packed integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBi8vec2\fP \fBunpackInt2x8(int16 p)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBint64\fP glm::packInt4x16 (\fBi16vec4\fP const & v)"
Convert each component from an integer vector into a packed integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBi16vec4\fP \fBunpackInt4x16(int64 p)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBint32\fP glm::packInt4x8 (\fBi8vec4\fP const & v)"
Convert each component from an integer vector into a packed integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBi8vec4\fP \fBunpackInt4x8(int32 p)\fP 
.RE
.PP

.SS "template<length_t L, typename T , qualifier Q> GLM_FUNC_DECL \fBvec\fP<4, T, Q> glm::packRGBM (\fBvec\fP< 3, T, Q > const & rgb)"
Returns an unsigned integer vector obtained by converting the components of a floating-point vector to the 16-bit floating-point representation found in the OpenGL Specification\&. The first vector component specifies the 16 least-significant bits of the result; the forth component specifies the 16 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec<3, T, Q>\fP \fBunpackRGBM(vec<4, T, Q> const& p)\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "template<typename intType , length_t L, typename floatType , qualifier Q> GLM_FUNC_DECL \fBvec\fP<L, intType, Q> glm::packSnorm (\fBvec\fP< L, floatType, Q > const & v)"
Convert each component of the normalized floating-point vector into signed integer values\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
vec<L, floatType, Q> \fBunpackSnorm(vec<L, intType, Q> const& p)\fP; 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packSnorm1x16 (float v)"
First, converts the normalized floating-point value v into 16-bit integer value\&. Then, the results are packed into the returned 16-bit unsigned integer\&.
.PP
The conversion to fixed point is done as follows: packSnorm1x8: round(clamp(s, -1, +1) * 32767\&.0)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackSnorm2x16(vec2 const& v)\fP 
.PP
\fBuint64\fP \fBpackSnorm4x16(vec4 const& v)\fP 
.PP
\fCGLSL packSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint8\fP glm::packSnorm1x8 (float s)"
First, converts the normalized floating-point value v into 8-bit integer value\&. Then, the results are packed into the returned 8-bit unsigned integer\&.
.PP
The conversion to fixed point is done as follows: packSnorm1x8: round(clamp(s, -1, +1) * 127\&.0)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP \fBpackSnorm2x8(vec2 const& v)\fP 
.PP
\fBuint32\fP \fBpackSnorm4x8(vec4 const& v)\fP 
.PP
\fCGLSL packSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packSnorm2x8 (\fBvec2\fP const & v)"
First, converts each component of the normalized floating-point value v into 8-bit integer values\&. Then, the results are packed into the returned 16-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packSnorm2x8: round(clamp(c, -1, +1) * 127\&.0)
.PP
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint8\fP packSnorm1x8(float const& v) 
.PP
\fBuint32\fP \fBpackSnorm4x8(vec4 const& v)\fP 
.PP
\fCGLSL packSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packSnorm3x10_1x2 (\fBvec4\fP const & v)"
First, converts the first three components of the normalized floating-point value v into 10-bit signed integer values\&. Then, converts the forth component of the normalized floating-point value v into 2-bit signed integer values\&. Then, the results are packed into the returned 32-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packSnorm3x10_1x2(xyz): round(clamp(c, -1, +1) * 511\&.0) packSnorm3x10_1x2(w): round(clamp(c, -1, +1) * 1\&.0)
.PP
The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec4\fP unpackSnorm3x10_1x2(uint32 const& p) 
.PP
\fBuint32\fP \fBpackUnorm3x10_1x2(vec4 const& v)\fP 
.PP
\fBuint32\fP \fBpackU3x10_1x2(uvec4 const& v)\fP 
.PP
\fBuint32\fP \fBpackI3x10_1x2(ivec4 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint64\fP glm::packSnorm4x16 (\fBvec4\fP const & v)"
First, converts each component of the normalized floating-point value v into 16-bit integer values\&. Then, the results are packed into the returned 64-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packSnorm2x8: round(clamp(c, -1, +1) * 32767\&.0)
.PP
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP packSnorm1x16(float const& v) 
.PP
\fBuint32\fP \fBpackSnorm2x16(vec2 const& v)\fP 
.PP
\fCGLSL packSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packU3x10_1x2 (\fBuvec4\fP const & v)"
Returns an unsigned integer obtained by converting the components of a four-component unsigned integer vector to the 10-10-10-2-bit unsigned integer representation found in the OpenGL Specification, and then packing these four values into a 32-bit unsigned integer\&. The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackI3x10_1x2(ivec4 const& v)\fP 
.PP
\fBuint32\fP \fBpackSnorm3x10_1x2(vec4 const& v)\fP 
.PP
\fBuint32\fP \fBpackUnorm3x10_1x2(vec4 const& v)\fP 
.PP
\fBivec4\fP unpackU3x10_1x2(uint32 const& p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER uint glm::packUint2x16 (\fBu16vec2\fP const & v)"
Convert each component from an integer vector into a packed unsigned integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBu16vec2\fP \fBunpackUint2x16(uint p)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint64\fP glm::packUint2x32 (\fBu32vec2\fP const & v)"
Convert each component from an integer vector into a packed unsigned integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBu32vec2\fP unpackUint2x32(int p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packUint2x8 (\fBu8vec2\fP const & v)"
Convert each component from an integer vector into a packed unsigned integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBu8vec2\fP unpackInt2x8(uint16 p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint64\fP glm::packUint4x16 (\fBu16vec4\fP const & v)"
Convert each component from an integer vector into a packed unsigned integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBu16vec4\fP \fBunpackUint4x16(uint64 p)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packUint4x8 (\fBu8vec4\fP const & v)"
Convert each component from an integer vector into a packed unsigned integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBu8vec4\fP \fBunpackUint4x8(uint32 p)\fP 
.RE
.PP

.SS "template<typename uintType , length_t L, typename floatType , qualifier Q> GLM_FUNC_DECL \fBvec\fP<L, uintType, Q> glm::packUnorm (\fBvec\fP< L, floatType, Q > const & v)"
Convert each component of the normalized floating-point vector into unsigned integer values\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
vec<L, floatType, Q> unpackUnorm(vec<L, intType, Q> const& p); 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packUnorm1x16 (float v)"
First, converts the normalized floating-point value v into a 16-bit integer value\&. Then, the results are packed into the returned 16-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packUnorm1x16: round(clamp(c, 0, +1) * 65535\&.0)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP packSnorm1x16(float const& v) 
.PP
\fBuint64\fP \fBpackSnorm4x16(vec4 const& v)\fP 
.PP
\fCGLSL packUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packUnorm1x5_1x6_1x5 (\fBvec3\fP const & v)"
Convert each component of the normalized floating-point vector into unsigned integer values\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec3\fP \fBunpackUnorm1x5_1x6_1x5(uint16 p)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint8\fP glm::packUnorm1x8 (float v)"
First, converts the normalized floating-point value v into a 8-bit integer value\&. Then, the results are packed into the returned 8-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packUnorm1x8: round(clamp(c, 0, +1) * 255\&.0)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP \fBpackUnorm2x8(vec2 const& v)\fP 
.PP
\fBuint32\fP \fBpackUnorm4x8(vec4 const& v)\fP 
.PP
\fCGLSL packUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint8\fP glm::packUnorm2x3_1x2 (\fBvec3\fP const & v)"
Convert each component of the normalized floating-point vector into unsigned integer values\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec3\fP \fBunpackUnorm2x3_1x2(uint8 p)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint8\fP glm::packUnorm2x4 (\fBvec2\fP const & v)"
Convert each component of the normalized floating-point vector into unsigned integer values\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec2\fP \fBunpackUnorm2x4(uint8 p)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packUnorm2x8 (\fBvec2\fP const & v)"
First, converts each component of the normalized floating-point value v into 8-bit integer values\&. Then, the results are packed into the returned 16-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packUnorm2x8: round(clamp(c, 0, +1) * 255\&.0)
.PP
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint8\fP packUnorm1x8(float const& v) 
.PP
\fBuint32\fP \fBpackUnorm4x8(vec4 const& v)\fP 
.PP
\fCGLSL packUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packUnorm3x10_1x2 (\fBvec4\fP const & v)"
First, converts the first three components of the normalized floating-point value v into 10-bit unsigned integer values\&. Then, converts the forth component of the normalized floating-point value v into 2-bit signed uninteger values\&. Then, the results are packed into the returned 32-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packUnorm3x10_1x2(xyz): round(clamp(c, 0, +1) * 1023\&.0) packUnorm3x10_1x2(w): round(clamp(c, 0, +1) * 3\&.0)
.PP
The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec4\fP unpackUnorm3x10_1x2(uint32 const& p) 
.PP
\fBuint32\fP \fBpackUnorm3x10_1x2(vec4 const& v)\fP 
.PP
\fBuint32\fP \fBpackU3x10_1x2(uvec4 const& v)\fP 
.PP
\fBuint32\fP \fBpackI3x10_1x2(ivec4 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packUnorm3x5_1x1 (\fBvec4\fP const & v)"
Convert each component of the normalized floating-point vector into unsigned integer values\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec4\fP \fBunpackUnorm3x5_1x1(uint16 p)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint64\fP glm::packUnorm4x16 (\fBvec4\fP const & v)"
First, converts each component of the normalized floating-point value v into 16-bit integer values\&. Then, the results are packed into the returned 64-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packUnorm4x16: round(clamp(c, 0, +1) * 65535\&.0)
.PP
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP packUnorm1x16(float const& v) 
.PP
\fBuint32\fP \fBpackUnorm2x16(vec2 const& v)\fP 
.PP
\fCGLSL packUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packUnorm4x4 (\fBvec4\fP const & v)"
Convert each component of the normalized floating-point vector into unsigned integer values\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec4\fP \fBunpackUnorm4x4(uint16 p)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec3\fP glm::unpackF2x11_1x10 (\fBuint32\fP p)"
First, unpacks a single 32-bit unsigned integer p into two 11-bit signless floating-point values and one 10-bit signless floating-point value \&. Then, each component is converted to a normalized floating-point value to generate the returned three-component vector\&.
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackF2x11_1x10(vec3 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec3\fP glm::unpackF3x9_E1x5 (\fBuint32\fP p)"
First, unpacks a single 32-bit unsigned integer p into two 11-bit signless floating-point values and one 10-bit signless floating-point value \&. Then, each component is converted to a normalized floating-point value to generate the returned three-component vector\&.
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
unpackF3x9_E1x5 allows decoding RGBE / RGB9E5 data
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackF3x9_E1x5(vec3 const& v)\fP 
.RE
.PP

.SS "template<length_t L, qualifier Q> GLM_FUNC_DECL \fBvec\fP<L, float, Q> glm::unpackHalf (\fBvec\fP< L, \fBuint16\fP, Q > const & p)"
Returns a floating-point vector with components obtained by reinterpreting an integer vector as 16-bit floating-point numbers and converting them to 32-bit floating-point values\&. The first component of the vector is obtained from the 16 least-significant bits of v; the forth component is obtained from the 16 most-significant bits of v\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
vec<L, uint16, Q> \fBpackHalf(vec<L, float, Q> const& v)\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER float glm::unpackHalf1x16 (\fBuint16\fP v)"
Returns a floating-point scalar with components obtained by unpacking a 16-bit unsigned integer into a 16-bit value, interpreted as a 16-bit floating-point number according to the OpenGL Specification, and converting it to 32-bit floating-point values\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec2\fP unpackHalf2x16(uint32 const& v) 
.PP
\fBvec4\fP unpackHalf4x16(uint64 const& v) 
.PP
\fCGLSL unpackHalf2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBglm::vec4\fP glm::unpackHalf4x16 (\fBuint64\fP p)"
Returns a four-component floating-point vector with components obtained by unpacking a 64-bit unsigned integer into four 16-bit values, interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, and converting them to 32-bit floating-point values\&. The first component of the vector is obtained from the 16 least-significant bits of v; the forth component is obtained from the 16 most-significant bits of v\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
float unpackHalf1x16(uint16 const& v) 
.PP
\fBvec2\fP unpackHalf2x16(uint32 const& v) 
.PP
\fCGLSL unpackHalf2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBivec4\fP glm::unpackI3x10_1x2 (\fBuint32\fP p)"
Unpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit signed integers\&.
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackU3x10_1x2(uvec4 const& v)\fP 
.PP
\fBvec4\fP unpackSnorm3x10_1x2(uint32 const& p); 
.PP
\fBuvec4\fP unpackI3x10_1x2(uint32 const& p); 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBi16vec2\fP glm::unpackInt2x16 (int p)"
Convert a packed integer into an integer vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
int \fBpackInt2x16(i16vec2 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBi32vec2\fP glm::unpackInt2x32 (\fBint64\fP p)"
Convert a packed integer into an integer vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
int packInt2x16(i32vec2 const& v) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBi8vec2\fP glm::unpackInt2x8 (\fBint16\fP p)"
Convert a packed integer into an integer vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBint16\fP \fBpackInt2x8(i8vec2 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBi16vec4\fP glm::unpackInt4x16 (\fBint64\fP p)"
Convert a packed integer into an integer vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBint64\fP \fBpackInt4x16(i16vec4 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBi8vec4\fP glm::unpackInt4x8 (\fBint32\fP p)"
Convert a packed integer into an integer vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBint32\fP packInt2x8(i8vec4 const& v) 
.RE
.PP

.SS "template<length_t L, typename T , qualifier Q> GLM_FUNC_DECL \fBvec\fP<3, T, Q> glm::unpackRGBM (\fBvec\fP< 4, T, Q > const & rgbm)"
Returns a floating-point vector with components obtained by reinterpreting an integer vector as 16-bit floating-point numbers and converting them to 32-bit floating-point values\&. The first component of the vector is obtained from the 16 least-significant bits of v; the forth component is obtained from the 16 most-significant bits of v\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec<4, T, Q>\fP packRGBM(vec<3, float, Q> const& v) 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "template<typename floatType , length_t L, typename intType , qualifier Q> GLM_FUNC_DECL \fBvec\fP<L, floatType, Q> glm::unpackSnorm (\fBvec\fP< L, intType, Q > const & v)"
Convert a packed integer to a normalized floating-point vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
vec<L, intType, Q> \fBpackSnorm(vec<L, floatType, Q> const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER float glm::unpackSnorm1x16 (\fBuint16\fP p)"
First, unpacks a single 16-bit unsigned integer p into a single 16-bit signed integers\&. Then, each component is converted to a normalized floating-point value to generate the returned scalar\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm1x16: clamp(f / 32767\&.0, -1, +1)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec2\fP \fBunpackSnorm2x16(uint32 p)\fP 
.PP
\fBvec4\fP \fBunpackSnorm4x16(uint64 p)\fP 
.PP
\fCGLSL unpackSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER float glm::unpackSnorm1x8 (\fBuint8\fP p)"
First, unpacks a single 8-bit unsigned integer p into a single 8-bit signed integers\&. Then, the value is converted to a normalized floating-point value to generate the returned scalar\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm1x8: clamp(f / 127\&.0, -1, +1)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec2\fP \fBunpackSnorm2x8(uint16 p)\fP 
.PP
\fBvec4\fP \fBunpackSnorm4x8(uint32 p)\fP 
.PP
\fCGLSL unpackSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec2\fP glm::unpackSnorm2x8 (\fBuint16\fP p)"
First, unpacks a single 16-bit unsigned integer p into a pair of 8-bit signed integers\&. Then, each component is converted to a normalized floating-point value to generate the returned two-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm2x8: clamp(f / 127\&.0, -1, +1)
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
float \fBunpackSnorm1x8(uint8 p)\fP 
.PP
\fBvec4\fP \fBunpackSnorm4x8(uint32 p)\fP 
.PP
\fCGLSL unpackSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec4\fP glm::unpackSnorm3x10_1x2 (\fBuint32\fP p)"
First, unpacks a single 32-bit unsigned integer p into four 16-bit signed integers\&. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm3x10_1x2(xyz): clamp(f / 511\&.0, -1, +1) unpackSnorm3x10_1x2(w): clamp(f / 511\&.0, -1, +1)
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackSnorm3x10_1x2(vec4 const& v)\fP 
.PP
\fBvec4\fP unpackUnorm3x10_1x2(uint32 const& p)) 
.PP
\fBuvec4\fP unpackI3x10_1x2(uint32 const& p) 
.PP
\fBuvec4\fP unpackU3x10_1x2(uint32 const& p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec4\fP glm::unpackSnorm4x16 (\fBuint64\fP p)"
First, unpacks a single 64-bit unsigned integer p into four 16-bit signed integers\&. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm4x16: clamp(f / 32767\&.0, -1, +1)
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
float \fBunpackSnorm1x16(uint16 p)\fP 
.PP
\fBvec2\fP \fBunpackSnorm2x16(uint32 p)\fP 
.PP
\fCGLSL unpackSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuvec4\fP glm::unpackU3x10_1x2 (\fBuint32\fP p)"
Unpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit unsigned integers\&.
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackU3x10_1x2(uvec4 const& v)\fP 
.PP
\fBvec4\fP unpackSnorm3x10_1x2(uint32 const& p); 
.PP
\fBuvec4\fP unpackI3x10_1x2(uint32 const& p); 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBu16vec2\fP glm::unpackUint2x16 (uint p)"
Convert a packed integer into an integer vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
uint \fBpackUint2x16(u16vec2 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBu32vec2\fP glm::unpackUint2x32 (\fBuint64\fP p)"
Convert a packed integer into an integer vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
int packUint2x16(u32vec2 const& v) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBu8vec2\fP glm::unpackUint2x8 (\fBuint16\fP p)"
Convert a packed integer into an integer vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP packInt2x8(u8vec2 const& v) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBu16vec4\fP glm::unpackUint4x16 (\fBuint64\fP p)"
Convert a packed integer into an integer vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint64\fP \fBpackUint4x16(u16vec4 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBu8vec4\fP glm::unpackUint4x8 (\fBuint32\fP p)"
Convert a packed integer into an integer vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP packUint4x8(u8vec2 const& v) 
.RE
.PP

.SS "template<typename floatType , length_t L, typename uintType , qualifier Q> GLM_FUNC_DECL \fBvec\fP<L, floatType, Q> glm::unpackUnorm (\fBvec\fP< L, uintType, Q > const & v)"
Convert a packed integer to a normalized floating-point vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
vec<L, intType, Q> \fBpackUnorm(vec<L, floatType, Q> const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER float glm::unpackUnorm1x16 (\fBuint16\fP p)"
First, unpacks a single 16-bit unsigned integer p into a of 16-bit unsigned integers\&. Then, the value is converted to a normalized floating-point value to generate the returned scalar\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnorm1x16: f / 65535\&.0
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec2\fP \fBunpackUnorm2x16(uint32 p)\fP 
.PP
\fBvec4\fP \fBunpackUnorm4x16(uint64 p)\fP 
.PP
\fCGLSL unpackUnorm2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec3\fP glm::unpackUnorm1x5_1x6_1x5 (\fBuint16\fP p)"
Convert a packed integer to a normalized floating-point vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP \fBpackUnorm1x5_1x6_1x5(vec3 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER float glm::unpackUnorm1x8 (\fBuint8\fP p)"
Convert a single 8-bit integer to a normalized floating-point value\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnorm4x8: f / 255\&.0
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec2\fP \fBunpackUnorm2x8(uint16 p)\fP 
.PP
\fBvec4\fP \fBunpackUnorm4x8(uint32 p)\fP 
.PP
\fCGLSL unpackUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec3\fP glm::unpackUnorm2x3_1x2 (\fBuint8\fP p)"
Convert a packed integer to a normalized floating-point vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint8\fP \fBpackUnorm2x3_1x2(vec3 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec2\fP glm::unpackUnorm2x4 (\fBuint8\fP p)"
Convert a packed integer to a normalized floating-point vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint8\fP \fBpackUnorm2x4(vec2 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec2\fP glm::unpackUnorm2x8 (\fBuint16\fP p)"
First, unpacks a single 16-bit unsigned integer p into a pair of 8-bit unsigned integers\&. Then, each component is converted to a normalized floating-point value to generate the returned two-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnorm4x8: f / 255\&.0
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
float \fBunpackUnorm1x8(uint8 v)\fP 
.PP
\fBvec4\fP \fBunpackUnorm4x8(uint32 p)\fP 
.PP
\fCGLSL unpackUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec4\fP glm::unpackUnorm3x10_1x2 (\fBuint32\fP p)"
First, unpacks a single 32-bit unsigned integer p into four 16-bit signed integers\&. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm3x10_1x2(xyz): clamp(f / 1023\&.0, 0, +1) unpackSnorm3x10_1x2(w): clamp(f / 3\&.0, 0, +1)
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackSnorm3x10_1x2(vec4 const& v)\fP 
.PP
\fBvec4\fP unpackInorm3x10_1x2(uint32 const& p)) 
.PP
\fBuvec4\fP unpackI3x10_1x2(uint32 const& p) 
.PP
\fBuvec4\fP unpackU3x10_1x2(uint32 const& p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec4\fP glm::unpackUnorm3x5_1x1 (\fBuint16\fP p)"
Convert a packed integer to a normalized floating-point vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP \fBpackUnorm3x5_1x1(vec4 const& v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec4\fP glm::unpackUnorm4x16 (\fBuint64\fP p)"
First, unpacks a single 64-bit unsigned integer p into four 16-bit unsigned integers\&. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnormx4x16: f / 65535\&.0
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
float \fBunpackUnorm1x16(uint16 p)\fP 
.PP
\fBvec2\fP \fBunpackUnorm2x16(uint32 p)\fP 
.PP
\fCGLSL unpackUnorm2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec4\fP glm::unpackUnorm4x4 (\fBuint16\fP p)"
Convert a packed integer to a normalized floating-point vector\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP \fBpackUnorm4x4(vec4 const& v)\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Typhoon Engine from the source code\&.
